Kubernetes Getting Started
Apr 2018

Ilias Dimos
DevOps Engineer, Pollfish
iliasdimos@gmail.com
@dosko64





* What is Kubernetes?
- A highly available cluster of computers, connected to work as a single unit
- Automates the distribution and scheduling of containers in that cluster
- Backed by a big community and Google
- A lot of enteprises put effort on the project


.image images/kubernetes.png




* Why Kubernetes
- Run new code in production without setting up servers (if you manage to setup a cluster)
- Fail over capabilities
- Easy see what you are running in the cluster
- Better use of your resources




* Setup 
Local 
- Minikube

Cloud Providers
- Google Kubernetes Engine
- Microsoft ACS Engine and AKS Engine
- Amazon EKS

Tools to setup your cluster
- kubeadm 
- kops 
- kubicorn

Cli tool 
- kubectl




* Enterprise Solutions 

- Juju by Canonical
- Tectonic  by CoreOS

- More at 
.link https://kubernetes.io/docs/setup/pick-right-solution/

There are a lot of resources out there on how to setup you cluster




* Architecture
Node Types: 

- *Master* / Node Controllers - a component which manages various aspects of nodes, health, availability, scheduling
- *Nodes* - a worker machine

And state is stored in

- *etcd* - Stores the state of the cluster and running components

    kubectl get nodes



* Architecture (2) / Configuration:

- *kubelet* - The agent that runs on each node
- *kube-apiserver* - REST operations with the cluster
- *kube-controller-manager* - Watches the shared state of the cluster and makes changes towards the desired state
- *kube-scheduler* - Watches over the cluster and acts accordingly to ensuer kube-controller-managere's requests. All are exposed through the API as necessary.




* Components: 

- *Pod* - The smallest deployable object
- *ReplicaSet* - Enables easily create multiple pods. Ensures a given nuber of pods always run. Keep history of deployments. Advance selector.
- *Deployment* - Replacement of RC, replication through RS, Rollout/rollback abilities.

- *ReplicationController* - Deprecated -  enables you to easily create multiple pods, then make sure that that number of pods always exists


    kubectl get pods 
    kubectl get rs 
    kubectl get deployment 

    kubectl get rc 

    kubectl get all

* Namespace 

- Virtual clusters in the same physical cluster

    kubectl get namespace
    kubectl get all --all-namespaces

- Kubeconfig 
    Env Variables
    KUBECONFIG 
    Default ~/.kube/config

    kubectl config view
    kubectl config set-context prod --cluster='kluster' --namespace='production' --user='kubelet'
    kubectl config use-context prod





* Okay, how i connect to this ?

*Services*

The entity that give us (loadbalanced) access to selected deployments/pods determined by labels 

Service are of the following types:

- ClusterIP
- NodePort
- LoadBalancer

    kubectl get svc 




* Okay, how i connect to this ? (2)

*Ingress*

a collection of rules that allow inbound connections to reach the cluster services.
(Imagine an Nginx in your cluster, with SSL termination and name-based routing)

.code examples/ingress.yaml

    kubectl get ingress

* Recap Components

.image images/Kube_basic_example.jpg


* Tools  
- kubectl 

** Demo

Basic kubectl commands

    kubectl run nginx --image=nginx --port=80
    kubectl expose deployment nginx --target-port=80 --type=NodePort
    kubectl get pods | deployment | svc | all 
    kubectl describe <resource>
    kubectl logs <pod_name>




* Working stack

- Use Yaml files (on git) for definitions for :

    Deployment (which includes -> ReplicaSet -> Pods)

    Service




* Deployment Simple Example 
.code -edit examples/deployment_simple.yaml


* Deployment Full Example
.code -edit examples/deployment1.yaml
    --> to be continued to editor deployment.yaml

* Service Example
.code -edit examples/service.yaml





* Demo (2)

Deployment and service

    (where 'worker' is the name of our deployment)

    kubectl create -f examples/deployment.yaml
    
    kubectl create -f examples/service.yaml

    kubectl replace -f examples/deployment.yaml

    kubectl set image deployment/worker worker=goweb:0.2

    kubectl scale --replicas=3 -f examples/deployment.yaml

    kubectl scale --replicas=1 deployment/worker

    kubectl rollout status deployment app-deployment

    kubectl rollout history deployment app-deployment

    kubectl rollout undo worker





* Final Notes

- Okay, I 've got my cluster what i need 
Service and Deployment definition for all workloads

- KubeDNS provide access to services in the form of :
<service-name>.<namespace>.svc

- Use Environmental Variables for config. (12 factor app)

- For everyting up to creation time, in pods, all resources are available in Environmental variables

- Always use limits for pods

- Create your services wisely and before deployments 


* Usefull shortcuts
    alias k='kubectl'
    alias kg='kubectl get'
    alias kga='kubectl get all'
    alias kgan='kubectl get all --all-namespaces'
    alias kcc='kubectl config use-context'
    alias kl='kubectl logs'
    alias klf='kubectl logs -f'
    alias kd='kubectl describe'
    alias ksn='kubectl -n kube-system'


Tools Suggestions: 
- oh-my-zsh kubectl autocomplete 
- VSCode kubernetes plugin


* Next steps 
- Configmaps
- Ingress
- RBAC
- Helm
- CI/CD consepts


* Presentation Available at 

.link https://go-talks.appspot.com/github.com/dosko64/kubernetes-getting-started/kubernetes-getting-started.slide


and code at 
.link https://github.com/dosko64/kubernetes-getting-started