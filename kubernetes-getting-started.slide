Kubernetes Getting Started
Apr 2018

Ilias Dimos
DevOps Engineer, Pollfish
iliasdimos@gmail.com
@dosko64





* What is Kubernetes?
- A highly available cluster of computers, connected to work as a single unit
- Automates the distribution and scheduling of containers in that cluster
- Backed by a big community and Google
- A lot of enteprises put effort on the project


.image images/kubernetes.png




* Why Kubernetes
- Run new code in production without setting up servers (if you manage to setup a cluster)
- Fail over capabilities
- Easy see what you are running in the cluster
- Better use of your resources




* Setup 
- Local 
    - Minikube

- Cloud Providers
    - Google Kubernetes Engine
    - Microsoft ACS Engine and AKS Engine
    - Amazon EKS

- Tools to setup your cluster
    - kubeadm 
    - kops 
    - kubicorn

- Cli tool 
    - kubectl




* Enterprise Solutions 

- Juju by Canonical

- Tectonic by CoreOS

- More at: 
.link https://kubernetes.io/docs/setup/pick-right-solution/

There are a lot of resources out there on how to setup you cluster




* Architecture
Node Types: 

- *Master* - Node Controllers - a component which manages various aspects of nodes, health, availability, scheduling
- *Worker* - reponsible for running our apps

    kubectl get nodes



* Architecture (2) / Configuration:

- *kubelet* - The agent that runs on each node

- *kube-apiserver* - REST operations with the cluster

- *kube-controller-manager* - Watches the shared state of the cluster and makes changes towards the desired state

- *kube-scheduler* - Watches over the cluster and acts accordingly to ensuer kube-controller-managere's requests. All are exposed through the API as necessary.

And state is stored in

- *etcd* 





* Components: 

- *Pod* - The smallest deployable object

- *ReplicationController* - Deprecated -  enables you to easily create multiple pods, then make sure that that number of pods always exists

- *ReplicaSet* - Enables easily create multiple pods. Ensures a given nuber of pods always run. Keep history of deployments. Advance selector.

- *Deployment* - Replacement of RC, replication through RS, Rollout/rollback abilities.



    kubectl get pods 
    kubectl get rs 
    kubectl get deployment 

    kubectl get rc 

    kubectl get all





* Okay, how i connect to this ?

*Services*

The entity that give us (loadbalanced) access to selected deployments/pods determined by labels 

Service are of the following types:

- ClusterIP
- NodePort
- LoadBalancer

    kubectl get svc 




* Okay, how i connect to this ? (2)

*Ingress*

a collection of rules that allow inbound connections to reach the cluster services.
(Imagine an Nginx in your cluster, with SSL termination and name-based routing)

.code examples/ingress.yaml

    kubectl get ingress

* Namespace 

- Virtual clusters in the same physical cluster

    kubectl get namespace
    kubectl get all --all-namespaces

- Kubeconfig 
    Env Variables
    KUBECONFIG 
    Default ~/.kube/config

    kubectl config view
    kubectl config set-context prod --cluster='kluster' --namespace='production' --user='kubelet'
    kubectl config use-context prod
: kubeconfig
    kubeconfig is a yaml file, so you can edit it by hand


* Recap Components

.image images/Kube_basic_example.jpg


* Tools  
- kubectl 

** Demo

Basic kubectl commands

    kubectl run nginx --image=nginx --port=80
    kubectl expose deployment nginx --target-port=80 --type=NodePort
    kubectl get pods | deployment | svc | all 
    kubectl describe <resource>
    kubectl logs <pod_name>




* Working stack

- Use Yaml files (on git) for definitions for :

    Deployment (which includes -> ReplicaSet -> Pods)

    Service




* Deployment Simple Example 
.code -edit examples/deployment_simple.yaml


* Deployment Full Example
.code -edit examples/deployment1.yaml
    --> to be continued to editor deployment.yaml

* Service Example
.code -edit examples/service.yaml





* Demo (2)

Deployment and service

: Create replace deployment 
    kubectl create -f examples/deployment.yaml
    
    kubectl create -f examples/service.yaml

    kubectl replace -f examples/deployment.yaml

    kubectl set image deployment/worker worker=goweb:0.2
: Scale 
    kubectl scale --replicas=3 -f examples/deployment.yaml

    kubectl scale --replicas=1 deployment/worker
: Rollback deployment
    kubectl rollout status deployment app-deployment

    kubectl rollout history deployment app-deployment

    kubectl rollout undo worker





* Final Notes

- We need Service and Deployment definition for all your workloads
- KubeDNS provide access to services in the form of: 
    <service-name>.<namespace>.svc
- For everyting up to creation time, in pods, all resources are available in Environmental variables

- Environmental Variables for configuration in your apps (12 factor app)

- Createhealthcheck in your apps

- Always apply limits for pods

- Create your services wisely and before deployments 


* Usefull shortcuts
    alias k='kubectl'
    alias kg='kubectl get'
    alias kga='kubectl get all'
    alias kgan='kubectl get all --all-namespaces'
    alias kcc='kubectl config use-context'
    alias kl='kubectl logs'
    alias klf='kubectl logs -f'
    alias kd='kubectl describe'
    alias ksn='kubectl -n kube-system'


Tools Suggestions: 
- oh-my-zsh kubectl autocomplete 
- VSCode kubernetes plugin


* Next steps 
- Configmaps
- Ingress
- RBAC
- Helm
- CI/CD consepts


* Presentation Available at 

.link https://go-talks.appspot.com/github.com/dosko64/kubernetes-getting-started/kubernetes-getting-started.slide


and code at 
.link https://github.com/dosko64/kubernetes-getting-started